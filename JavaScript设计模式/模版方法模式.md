# 第十章 模版方法模式

在JavaScript中，我们可以通过原型prototype来变相地实现继承。

模版方法模式则是一种基于继承的设计模式。

## 11.1 模版方法模式的定义和组成

模版方法是一种只需使用继承就可以实现的模式。

分两个部分组成：第一部分是抽象父类，第二部分是具体的实现子类。

通常在抽象的父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中的所有方法的执行顺序。

子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。

例如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同的和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但是实际上，相同的行为可以被搬移到另外一个单一的地方，模版方法模式就是为解决这个问题而生的。在模版方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也体现了泛化的思想。

## 11.2 第一个例子——Coffee or Tea

泡咖啡的例子可以用来讲解模版方法

### 11.2.1 先泡一杯咖啡

泡咖啡的步骤如下：

1. 把水煮沸
2. 用沸水冲泡咖啡
3. 把咖啡倒进杯子
4. 加糖和牛奶

下面我们用代码实现：

```javascript
function Coffee() {}

Coffee.prototype.boilWater = function() {
  console.log('把水煮沸')
}

Coffee.prototype.brewCoffeeGriends = function() {
  console.log('用沸水冲泡咖啡')
}

Coffee.prototype.pourInCup = function() {
  console.log('把咖啡倒进杯子里')
}

Coffee.prototype.addSugarAndMilk = function() {
  console.log('加糖和牛奶')
}

Coffee.prototype.init = function() {
  this.boilWater()
  this.brewCoffeeGriends()
  this.pourInCup()
  this.addSugarAndMilk()
}

var coffee = new Coffee()
coffee.init()
```

### 11.2.2 泡一壶茶

接下来，开始准备我们的茶，泡茶的步骤跟泡咖啡的差不多

1. 把水煮沸
2. 用沸水浸泡茶叶
3. 把茶水倒进杯子
4. 加柠檬

```javascript
function Tea() {}

Tea.prototype.boilWater = function() {
  console.log('把水煮沸')
}

Tea.prototype.steepTeaBag = function() {
  console.log('用沸水浸泡茶叶')
}

Tea.prototype.pourInCup = function() {
  console.log('把茶水倒进杯子里')
}

Tea.prototype.addLemon = function() {
  console.log('加柠檬')
}

Tea.prototype.init = function() {
  this.boilWater()
  this.steepTeaBag()
  this.pourInCup()
  this.addLemon()
}

var tea = new Tea()
tea.init()
```

### 11.2.3 分离出共同点

经过比较，我们发现冲咖啡与茶的过程是大同小异的：

| 泡咖啡           | 泡茶             |
| ---------------- | ---------------- |
| 把水煮沸         | 把水煮沸         |
| 用沸水冲泡咖啡   | 用沸水浸泡茶叶   |
| 把咖啡倒进杯子里 | 把茶水倒进杯子里 |
| 加糖和牛奶       | 加柠檬           |

泡咖啡跟泡茶的不同点如下：

* 原料不同。一个是咖啡，一个是茶，我们将其抽象成饮料
* 泡的方式不同，咖啡用冲泡，茶叶是浸泡。我们将其抽象成泡
* 调料不同，咖啡用糖和牛奶，茶用柠檬。我们将其抽象成调料

最后我们总结成如下过程：

* 把水煮沸
* 用沸水泡饮料
* 把饮料倒进杯子
* 加调料

那么，我们将冲泡的方法定义为brew，将加调料的方法定义为addCondiments，将饮料抽象成Beverage类

```JavaScript
        var Beverage = function(){};
        Beverage.prototype.boilWater = function(){
            console.log( ’把水煮沸’ );
        };

        Beverage.prototype.brew = function(){};      // 空方法，应该由子类重写

        Beverage.prototype.pourInCup = function(){};    // 空方法，应该由子类重写

        Beverage.prototype.addCondiments = function(){};    // 空方法，应该由子类重写

        Beverage.prototype.init = function(){
            this.boilWater();
            this.brew();
            this.pourInCup();
            this.addCondiments();
        };
```

### 11.2.4 创建Coffee子类和Tea子类

创建Coffee类，并继承Beverage类

```javascript
        var Coffee = function() {};

        Coffee.prototype = Object.create(Beverage.prototype)
```

接下来重写Coffee类的方法

```javascript
        Coffee.prototype.brew = function() {
          console.log('沸水冲泡咖啡')
        };

        Coffee.prototype.pourInCup = function() {
          console.log('咖啡倒进杯子')
        };
        Coffee.prototype.addCondiments = function() {
          console.log('糖和牛奶');
        };

        var coffee = new Coffee();
        coffee.init();
```

当我们创建coffee对象后，调用coffee的init方法，此时coffee本身没有init方法，于是会顺着原型链，被委托给Coffee类的父类Beverage类的原型上的init方法。

由于Beverage.prototype.init方法中已经规定好了泡饮料的顺序，于是这时成功泡出了咖啡

```javascript
        Beverage.prototype.init = function() {
          this.boilWater();
          this.brew();
          this.pourInCup();
          this.addCondiments();
        };
```

同样的方法我们还可以应用给Tea类，这里就不展开讨论了。

这里的Beverage.prototype.init就是模版方法。

Beverage.prototype.init被称为模版方法的原因是，该方法封装了子类的算法框架，它作为一个算法的框架，指导子类以何种顺序去执行这些方法。在Beverage.prototype.init方法中，算法内的每一步都呈现在我们面前。



