# 一、事件简介

事件是某些事发生的信号。所有DOM节点都可以生成这样的信号。

以下是常用DOM事件列表：

* 鼠标事件
  * `click` — 当鼠标点击一个元素时
  * `contextmenu` — 当鼠标右键点击一个元素时
  * `mouseover/mouseout` — 当鼠标移入/移除一个元素时
  * `mousedown/mouseup` — 当在元素上上按下/抬起鼠标时
  * `mousemove` — 当鼠标移动时
* 键盘事件
  * `keydown/keyup` — 当按下和松开一个按键时
* 表单事件
  * `submit` — 当访问者提交了一个`form`时
  * `focus` — 当访问者聚焦一个元素时
* Document事件
  * `DOMContentLoaded` — 当HTML的加载和处理均完成，DOM被完全构建完成时
* CSS事件
  * `transitionend` — 当一个css动画完成时

## 1.1 事件处理程序

为了对事件做出响应，我们可以在代码中给相应的元素分配一个处理程序—— 即事件函数。

当发生用户行为（action）时会运行这个函数。

有三种添加事件处理程序的方式：

* HTML 特性

  处理程序可以写在HTML的`on(event)`特性中。

  例如，以下是给`input`分配一个`click`的处理程序。

  ```html
  <input value="Click me" onclick="alert('Click!')" type="button">
  ```

  当鼠标点击时，代码就会运行。

  由于特性本身使用的是双引号，所以我们在代码中需要使用非双引号，否则代码无法被正确解析，也就无法正确运行。

  在特性中，我们没办法大量书写JavaScript代码，因此我们最好创建一个函数，然后在HTML特性中调用这个函数。

  ```html
  <script>
    function countRabbits() {
      for(let i=1; i<=3; i++) {
        alert("Rabbit number " + i);
      }
    }
  </script>
  
  <input type="button" onclick="countRabbits()" value="Count rabbits!">
  ```

  HTML 特性名是大小写不敏感的，所以 `ONCLICK` 和 `onClick` 以及 `onCLICK` 都一样可以运行。但是特性通常是小写的：`onclick`。

* DOM属性

  标准特性跟DOM属性总是有映射关系的，我们可以使用DOM属性`on(event)`来分配处理程序。

  例如：

  ```html
  <input id="elem" type="button" value="Click me">
  <script>
    elem.onclick = function() {
      alert('Thank you');
    };
  </script>
  ```

  如果处理程序是通过HTML特性的方式来写的，那么浏览器会读取它，并从特性的内容创建一个**新的函数**，然后将这个函数写入DOM属性。

  因此，DOM属性和HTML特性的两种写法效果是一样的，只是初始化的方式不同。特性是从HTML中初始化，属性是从DOM属性中初始化。

  如果我们希望一个元素的一个事件有两个事件处理程序怎么办？由于一个元素只有一个onclick属性，所以我们没办法通过HTML和DOM的方式来实现这样的功能。


## 1.2 访问元素：this

处理程序中的this值是对应的元素。就是处理程序所在的那个元素。

  ```html
  <button onclick="alert(this.innerHTML)">Click me</button>
  // 会输出：Click me
  ```



## 1.3 可能出现的错误

  1. DOM属性中的事件处理程序不要加括号
  2. HTML特性中的事件处理程序需要加括号。因为特性转化成属性时，浏览器会自动创建一个函数，并让这个函数执行特性中的内容
  3. DOM属性大小写敏感，HTML大小写不敏感
  4. `elem.setAttribute("onclick", "alert(123)")`，也可以这样写HTML特性。

  

  ## 1.4 addEventListener

我们可以用发布订阅模式来给事件分配**多个**处理程序，这就用到 `addEventListener` 和 `removeEventListener`

添加处理程序的语法：

```javascript
element.addEventListener(event, handler[, options]);
```

`event`

事件名

`handler`

处理程序

`options`

是具有以下属性的附加可选对象：

* once ： 如果为`true`，可以在触发后自动删除监听器
* capture：事件处理阶段，false为冒泡阶段，true是捕获阶段
* passive：如果为`true`，处理程序将不会调用`preventDefault`



移除处理程序的语法：

```javascript
element.removeEventListener(event, handler[, options]);
```

> 要移除处理程序，我们需要传入与分配函数的地址完全相同的函数。
>
> ```javascript
> elem.addEventListener( "click" , () => alert('Thanks!'));
> // ....
> elem.removeEventListener( "click", () => alert('Thanks!'));
> //相同的代码，完全无用
> ```
>
> ```javascript
> function handler() {
>   alert( 'Thanks!' );
> }
> 
> input.addEventListener("click", handler);
> // ....
> input.removeEventListener("click", handler);
> // 这种方式才有效
> ```
>
> 请注意 —— 如果我们不将函数存储在一个变量中，那么我们就无法移除它。由 `addEventListener` 分配的处理程序将无法被“读回”。



多次调用`addEventListener`允许添加多个处理程序。

```javascript
  function handler1() {
    alert('Thanks!');
  };

  function handler2() {
    alert('Thanks again!');
  }

  elem.onclick = () => alert("Hello");
  elem.addEventListener("click", handler1); // Thanks!
  elem.addEventListener("click", handler2); // Thanks again!
```

一般我们会选择DOM属性或者`addEventListener`其中一种来添加事件处理程序。

对于某些事件，我们无法通过DOM属性来分配。只能使用 `addEventListener`。

比如`DOMContentLoaded`事件，该事件在文档加载完成且DOM构建完成时触发。

```javascript
// 这种方式可以运行
document.addEventListener("DOMContentLoaded", function() {
  alert("DOM built");
});

// 永远不会运行
document.onDOMContentLoaded = function() {
  alert("DOM built");
};
```

## 1.5 事件对象

当事件发生后，浏览器会创建一个`event`对象，将详细信息放在其中，并将其作为参数传递给处理程序。

event对象有一些属性：

`event.type`—事件类型

`event.currentTarget`— 处理事件的元素。与this相同，除非处理程序是箭头函数，或者它的this绑定到了其他东西上，那我们就可以用`event.currentTarget`来获取元素

`event.clientX/clientY`— 指针事件的指针的窗口相对坐标。

...等等

以下是从event对象中获取鼠标指针的坐标的示例：

```html
<input type="button" value="Click me" id="elem">

<script>
  elem.onclick = function(event) {
    // 显示事件类型、元素和点击的坐标
    alert(event.type + " at " + event.currentTarget);
    alert("Coordinates: " + event.clientX + ":" + event.clientY);
  };
</script>
```

在HTML特性中，我们可以这样使用event对象

```html
<input type="button" onclick="alert(event.type)" value="Event type">
```

## 1.6 对象处理程序：handleEvent

除了可以使用函数来作为事件处理程序，还可以使用对象的形式。当事件发生时，会调用这个对象内部的`handleEvent`方法。

```javascript
  let obj = {
    handleEvent(event) {
      alert(event.type + " at " + event.currentTarget);
    }
  };

  elem.addEventListener('click', obj);
```

只要能读取到这个对象的`handleEvent`方法，那么`handleEvent`写在原型上也是没问题的，以下是通过类创建对象处理程序的示例，`handleEvent`会放在类的原型上。

```javascript
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Mouse button pressed";
          break;
        case 'mouseup':
          elem.innerHTML += "...and released.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
```

利用对象处理程序，我们不必让`handleEvent`通过自己来处理，它可以调用其他特定于事件的方法

```javascript
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method](event);
    }

    onMousedown() {
      elem.innerHTML = "Mouse button pressed";
    }

    onMouseup() {
      elem.innerHTML += "...and released.";
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
```

现在事件处理程序已经明确分离出来了，更容易代码的编写和后期的维护。

> 在handleEvent方法中，this是当前对象

## 1.7 小结

有三种添加事件处理程序的方式：

* HTML特性方法
* DOM属性方法
* `addEventListener`方法,`removeEventListener` 用于移除

HTML特性很少用，因为在字符串中写JavaScript代码看起来跟奇怪。

DOM属性还不错，但是无法添加多个处理程序

`addEventListener`最灵活，有一些事件只支持这种方式。同时`addEventListener`还支持对象作为事件处理程序，在这种情况下，会调用对象中的`handleEvent`方法。

无论用哪种方式，都会接受浏览器处理过的`event`对象作为第一个参数，通过这个参数我们可以获取一些事件信息，比如鼠标坐标，事件类型等。
