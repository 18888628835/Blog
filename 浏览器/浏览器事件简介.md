# 一、事件简介

事件是某些事发生的信号。所有DOM节点都可以生成这样的信号。

以下是常用DOM事件列表：

* 鼠标事件
  * `click` — 当鼠标点击一个元素时
  * `contextmenu` — 当鼠标右键点击一个元素时
  * `mouseover/mouseout` — 当鼠标移入/移除一个元素时
  * `mousedown/mouseup` — 当在元素上上按下/抬起鼠标时
  * `mousemove` — 当鼠标移动时
* 键盘事件
  * `keydown/keyup` — 当按下和松开一个按键时
* 表单事件
  * `submit` — 当访问者提交了一个`form`时
  * `focus` — 当访问者聚焦一个元素时
* Document事件
  * `DOMContentLoaded` — 当HTML的加载和处理均完成，DOM被完全构建完成时
* CSS事件
  * `transitionend` — 当一个css动画完成时

## 1.1 事件处理程序

为了对事件做出响应，我们可以在代码中给相应的元素分配一个处理程序—— 即事件函数。

当发生用户行为（action）时会运行这个函数。

有三种添加事件处理程序的方式：

* HTML 特性

  处理程序可以写在HTML的`on(event)`特性中。

  例如，以下是给`input`分配一个`click`的处理程序。

  ```html
  <input value="Click me" onclick="alert('Click!')" type="button">
  ```

  当鼠标点击时，代码就会运行。

  由于特性本身使用的是双引号，所以我们在代码中需要使用非双引号，否则代码无法被正确解析，也就无法正确运行。

  在特性中，我们没办法大量书写JavaScript代码，因此我们最好创建一个函数，然后在HTML特性中调用这个函数。

  ```html
  <script>
    function countRabbits() {
      for(let i=1; i<=3; i++) {
        alert("Rabbit number " + i);
      }
    }
  </script>
  
  <input type="button" onclick="countRabbits()" value="Count rabbits!">
  ```

  HTML 特性名是大小写不敏感的，所以 `ONCLICK` 和 `onClick` 以及 `onCLICK` 都一样可以运行。但是特性通常是小写的：`onclick`。

* DOM属性

  标准特性跟DOM属性总是有映射关系的，我们可以使用DOM属性`on(event)`来分配处理程序。

  例如：

  ```html
  <input id="elem" type="button" value="Click me">
  <script>
    elem.onclick = function() {
      alert('Thank you');
    };
  </script>
  ```

  如果处理程序是通过HTML特性的方式来写的，那么浏览器会读取它，并从特性的内容创建一个**新的函数**，然后将这个函数写入DOM属性。

  因此，DOM属性和HTML特性的两种写法效果是一样的，只是初始化的方式不同。特性是从HTML中初始化，属性是从DOM属性中初始化。

  如果我们希望一个元素的一个事件有两个事件处理程序怎么办？由于一个元素只有一个onclick属性，所以我们没办法通过HTML和DOM的方式来实现这样的功能。


## 1.2 访问元素：this

处理程序中的this值是对应的元素。就是处理程序所在的那个元素。

  ```html
  <button onclick="alert(this.innerHTML)">Click me</button>
  // 会输出：Click me
  ```



## 1.3 可能出现的错误

  1. DOM属性中的事件处理程序不要加括号
  2. HTML特性中的事件处理程序需要加括号。因为特性转化成属性时，浏览器会自动创建一个函数，并让这个函数执行特性中的内容
  3. DOM属性大小写敏感，HTML大小写不敏感
  4. `elem.setAttribute("onclick", "alert(123)")`，也可以这样写HTML特性。

  

  ## 1.4 addEventListener

我们可以用发布订阅模式来给事件分配**多个**处理程序，这就用到 `addEventListener` 和 `removeEventListener`

添加处理程序的语法：

```javascript
element.addEventListener(event, handler[, options]);
```

`event`

事件名

`handler`

处理程序

`options`

是具有以下属性的附加可选对象：

* once ： 如果为`true`，可以在触发后自动删除监听器
* capture：事件处理阶段，false为冒泡阶段，true是捕获阶段
* passive：如果为`true`，处理程序将不会调用`preventDefault`



移除处理程序的语法：

```javascript
element.removeEventListener(event, handler[, options]);
```

> 要移除处理程序，我们需要传入与分配函数的地址完全相同的函数。
>
> ```javascript
> elem.addEventListener( "click" , () => alert('Thanks!'));
> // ....
> elem.removeEventListener( "click", () => alert('Thanks!'));
> //相同的代码，完全无用
> ```
>
> ```javascript
> function handler() {
>   alert( 'Thanks!' );
> }
> 
> input.addEventListener("click", handler);
> // ....
> input.removeEventListener("click", handler);
> // 这种方式才有效
> ```
>
> 请注意 —— 如果我们不将函数存储在一个变量中，那么我们就无法移除它。由 `addEventListener` 分配的处理程序将无法被“读回”。



多次调用`addEventListener`允许添加多个处理程序。

```javascript
  function handler1() {
    alert('Thanks!');
  };

  function handler2() {
    alert('Thanks again!');
  }

  elem.onclick = () => alert("Hello");
  elem.addEventListener("click", handler1); // Thanks!
  elem.addEventListener("click", handler2); // Thanks again!
```

一般我们会选择DOM属性或者`addEventListener`其中一种来添加事件处理程序。

对于某些事件，我们无法通过DOM属性来分配。只能使用 `addEventListener`。

比如`DOMContentLoaded`事件，该事件在文档加载完成且DOM构建完成时触发。

```javascript
// 这种方式可以运行
document.addEventListener("DOMContentLoaded", function() {
  alert("DOM built");
});

// 永远不会运行
document.onDOMContentLoaded = function() {
  alert("DOM built");
};
```

## 1.5 事件对象

当事件发生后，浏览器会创建一个`event`对象，将详细信息放在其中，并将其作为参数传递给处理程序。

event对象有一些属性：

`event.type`—事件类型

`event.currentTarget`— 处理事件的元素。与this相同，除非处理程序是箭头函数，或者它的this绑定到了其他东西上，那我们就可以用`event.currentTarget`来获取元素

`event.clientX/clientY`— 指针事件的指针的窗口相对坐标。

...等等

以下是从event对象中获取鼠标指针的坐标的示例：

```html
<input type="button" value="Click me" id="elem">

<script>
  elem.onclick = function(event) {
    // 显示事件类型、元素和点击的坐标
    alert(event.type + " at " + event.currentTarget);
    alert("Coordinates: " + event.clientX + ":" + event.clientY);
  };
</script>
```

在HTML特性中，我们可以这样使用event对象

```html
<input type="button" onclick="alert(event.type)" value="Event type">
```

## 1.6 对象处理程序：handleEvent

除了可以使用函数来作为事件处理程序，还可以使用对象的形式。当事件发生时，会调用这个对象内部的`handleEvent`方法。

```javascript
  let obj = {
    handleEvent(event) {
      alert(event.type + " at " + event.currentTarget);
    }
  };

  elem.addEventListener('click', obj);
```

只要能读取到这个对象的`handleEvent`方法，那么`handleEvent`写在原型上也是没问题的，以下是通过类创建对象处理程序的示例，`handleEvent`会放在类的原型上。

```javascript
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Mouse button pressed";
          break;
        case 'mouseup':
          elem.innerHTML += "...and released.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
```

利用对象处理程序，我们不必让`handleEvent`通过自己来处理，它可以调用其他特定于事件的方法

```javascript
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method](event);
    }

    onMousedown() {
      elem.innerHTML = "Mouse button pressed";
    }

    onMouseup() {
      elem.innerHTML += "...and released.";
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
```

现在事件处理程序已经明确分离出来了，更容易代码的编写和后期的维护。

> 在handleEvent方法中，this是当前对象

## 1.7 小结

有三种添加事件处理程序的方式：

* HTML特性方法
* DOM属性方法
* `addEventListener`方法,`removeEventListener` 用于移除

HTML特性很少用，因为在字符串中写JavaScript代码看起来跟奇怪。

DOM属性还不错，但是无法添加多个处理程序

`addEventListener`最灵活，有一些事件只支持这种方式。同时`addEventListener`还支持对象作为事件处理程序，在这种情况下，会调用对象中的`handleEvent`方法。

无论用哪种方式，都会接受浏览器处理过的`event`对象作为第一个参数，通过这个参数我们可以获取一些事件信息，比如鼠标坐标，事件类型等。

# 二、冒泡和捕获

## 2.1 冒泡

冒泡的原理是：当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行父元素的处理程序，然后一直向上到其他祖先上的处理程序。

几乎所有事件都会冒泡。

## 2.2 event.target

父元素上的处理程序始终可以获取事件实际发生位置的详细信息

引发事件的那个嵌套层级最深的元素被称为目标元素，可以通过`event.target`访问。

以下是`event.target`与`event.currentTarget`的区别：

* `event.target` —— 引发事件的目标元素，它在冒泡过程中不会变化，当点击事件发生在自身时，它就是`this`
* `event.currentTarget` ——正在运行处理程序的当前元素（绑定了处理程序的元素），它会变化。大部分情况下，它就是`this`

```html
    <button id="btn">我不是嵌套元素</button>
    <div id="div">
      <p>我是嵌套元素</p>
    </div>
    <script>
      btn.onclick = function (event) {
        console.log(this === event.currentTarget); //true
        console.log(this === event.target); //true
      };
      div.onclick = function (event) {
        console.log(this === event.currentTarget); //true
        console.log(this === event.target); //false
      };
    </script>
```

上面的代码中，当点击了`p`标签时，会触发父盒子`div`的事件处理程序，此时`this`就是`currentTarget`而不是`target`

## 2.3 停止冒泡

冒泡事件从目标元素开始向上冒泡。通常，它会一直升到`html`，然后再到`document`对象，有些事件甚至会到达`window`。

但是我们可以调用`event.stopPropagation()`控制不让其冒泡。

```html
<body onclick="alert(`the bubbling doesn't reach here`)">
  <button onclick="event.stopPropagation()">Click me</button>
</body>
```

如果一个元素有多个事件处理程序，当其中一个停止冒泡后，其他处理程序也会运行，但不会再冒泡。

```html
  <body onclick="alert('点击到我了')">
    <button id="btn">点记我</button>

    <script>
      btn.addEventListener("click", function (event) {
        event.stopPropagation();
        console.log(123);
      });
      btn.addEventListener("click", function () {
        console.log(456);
      });
    </script>
  </body>
```

> 有一个 `event.stopImmediatePropagation()` 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。使用该方法之后，其他处理程序就不会被执行。

**不要在没有需要的情况下停止冒泡！**

有时停止冒泡会造成隐藏的陷阱。

比如：

我们创建了一个嵌套菜单，每个子菜单都有自己的点击事件，并停止冒泡。

但如果我们下一步决定追踪用户在浏览器窗口内点击的位置，以做某些分析处理，那么被冒泡的那个区域很明显会变成一个死区，用户的行为我们不能记录下来了。

所以通常没有必要去阻止冒泡。 

## 2.4 捕获

事件处理的另外一个阶段是捕获（“capturing”）。

事件传播有三个阶段：

* 捕获阶段—— 事件从window向下走近元素
* 到达目标阶段——事件到达目标元素
* 冒泡——事件从元素上开始冒泡

![image-20220111215152710](../assets/image-20220111215152710.png)

以`table`为例，当我们点击`<td>`时，事件会通过祖先向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升到冒泡阶段。在途中调用处理程序。

默认使用 `on<event>` 属性或使用 HTML 特性（attribute）或使用两个参数的 `addEventListener(event, handler)` 添加的处理程序，对捕获一无所知，它们仅在第二阶段和第三阶段运行。

如果我们希望在捕获阶段处理事件，那么可以将处理程序的`capture`选项设置为`true`

```javascript
elem.addEventListener(..., {capture: true})
// 或者，用 {capture: true} 的别名 "true"
elem.addEventListener(..., true)
```

`capture` 选项有两个可能的值：

- 如果为 `false`（默认值），则在冒泡阶段设置处理程序。
- 如果为 `true`，则在捕获阶段设置处理程序。

请注意，虽然形式上有 3 个阶段，但第 2 阶段（“目标阶段”：事件到达元素）没有被单独处理：捕获阶段和冒泡阶段的处理程序都在该阶段被触发。

> **要移除处理程序，`removeEventListener` 需要同一阶段**
>
> 如果我们 `addEventListener(..., true)`，那么我们应该在 `removeEventListener(..., true)` 中提到同一阶段，以正确删除处理程序。

## 2.5 小结

当一个事件发生时 —— 发生该事件的嵌套最深的元素被标记为“目标元素”（`event.target`）。

* 事件从文档根节点向下移动到`event.target`，并在途中会调用分配了`addEventListener(...,true)`的处理程序
* 然后，在目标元素自身调用处理程序
* 然后，事件开始冒泡，从下到上冒泡到根，会调用`on<event>`、HTML 特性（attribute）和没有第三个参数的，或者第三个参数为 `false/{capture:false}` 的 `addEventListener` 分配的处理程序。

每个处理程序都可以访问到`event`对象的属性：

* `event.target` —— 引发事件的元素
* `event.currentTarget` —— 具有处理程序的元素
* `event.eventPhase` —— 当前阶段（capturing=1，target=2，bubbling=3）

捕获阶段很少使用，通常我们会在冒泡（默认）时处理事件。

每个处理程序都可以通过调用`event.stopPropagation`来停止冒泡。但不建议这样做，因为我们不确定是否确实不需要冒泡上来的事件。

> event.stopPropagation()也可以用于捕获阶段,所以更确切的叫法应该是停止传播

冒泡和捕获为“事件委托”奠定了基础 —— 一种非常强大的事件处理模式。
