# 一、性能优化思路

性能优化的最终目标是提高用户体验。

当用户将url输入浏览器后，会发生以下过程：

1. DNS解析，通过域名查找服务器IP
2. 建立TCP连接
3. HTTP请求
4. 服务器将结果返回给浏览器
5. 浏览器解析返回的结果并渲染页面

性能优化就是尽可能提高这几个过程的效率，让用户更快、更爽地与客户端进行交互。

比如说：

* 建立HTTP请求是非常消耗网络资源和服务器资源的行为，我们可以减少请求次数和减少请求花费的时间
* 静态资源从服务器返回给客户端同样消耗带宽和服务器，我们可以利用CDN和HTTP缓存加快请求静态资源的速度
* 浏览器的回流非常消耗性能，我们可以在代码上优化DOM，比如React使用useMemo和useCallback等钩子来减少非必要的组件更新
* 用节流和防抖来延缓用户频繁操作带来的副作用
* 浏览器一次性需要渲染的内容太多，可能导致白屏，用户等待焦灼，可以放一个骨架屏延缓用户焦虑
* 渲染长列表时，可能因为数据量太大导致浏览器卡顿，我们可以利用分时函数（timeChunk）来慢慢渲染页面或者将数据缓存、分页
* ...

总的来说，前端性能优化就是从网络、资源消耗、浏览器渲染这三个维度入手，对每个过程进行优化。



# 二、资源压缩合并-Webpack性能调优

HTTP优化有两个大方向：

* 减少请求次数
* 减少单次请求花费的时间

一个网站可能有非常多的静态资源、JS文件，如果能够减少静态资源的体积，合并某些静态资源（比如很多个css样式表），那么就能够对HTTP进行优化。

对**资源的压缩和合并**，我们可以利用打包工具来完成。目前打包工具主流还是使用 webpack，通过合理优化webpack的配置，能够让资源的压缩与合并达到理想的效果。

优化webpack的思路也是两个方向：

* 更快（提高构建速度，减少花费时间）
* 更小（减少打包体积）



## 2.1 如何更快——优化打包速度

打包速度影响到的是开发过程中的热更新速度以及上线前的构建速度。

通过以下方式我们可以优化打包速度：

### mode属性

webpack内部对`production`或者`development`有做优化，所以针对开发和生产环境我们需要配置不同的`mode`。

### resolve配置

通过`resolve`解析规则，我们可以手动控制`webpack`的查找规则，除了对开发友好外，相当于显式告诉`webpack`利用`resolve`中的配置规则查找文件，合理的配置会提高`webpack`查找文件的效率。

- **alias设置别名**

  通过`alisa`设置别名可以让`webpack`通过规则项从上到下查找文件，而不是递归查找。

  ```javascript
      alias: {
        '@': path.resolve(process.cwd(), 'src'),
      },
  ```

  通过上面的别名设置，除了让我们开发时可以通过`import xx from '@/xxx'` 引用`src`目录下的内容以外，还对`webpack`的查找规则非常友好——`webpack`知道可以`src`目录从上到下查找文件，而不是通过相对路径递归向上查找文件。

- **extensions高频扩展名前置**

  通过设置`extensions`可以在引入时不写扩展名。

  ```javascript
    resolve: {
      extensions: ['.js', '.jsx', '.tsx'],
    },
  ```

  webpack会从前到后遍历`extensions`属性来匹配是否有对应扩展名的文件，一些高频的后缀放在前面可以提高webpack搜索的速度

- **`modules`告诉webpack 解析模块时应该搜索的目录**

  ```javascript
  const path = require('path');
  
  module.exports = {
    //...
    resolve: {
      modules: [path.resolve(__dirname, 'src'), 'node_modules'],
    },
  };
  ```

  上面的代码将告诉`webpack`搜索`src`目录和`node_modules`目录，`src`目录优先搜索。

  这样有助于加快搜索时间

### cache属性

```javascript
module.exports = {
  //...
  cache: {
    type: 'filesystem',
  },
};
```

通过设置cache属性为文件系统缓存生成的 webpack 模块和 chunk，来改善构建速度。

### thread-loader

在耗时的操作中使用此loader可以生成独立的worker池。每个 worker 都是一个独立的 node.js 进程。

相当于开启了多进程来处理耗时慢的`loader`，这样就达到了多`loader`同时处理的效果。

下面是官方文档的示例：

```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve('src'),
        use: [
          "thread-loader",
          // 耗时的 loader （例如 babel-loader）
        ],
      },
    ],
  },
};
```

### 指定 include 或 exclude 

最常见的方式是通过`include`或`exclude`属性来帮我们避免不必要的转译，以 babel-loader 为例

```javascript
module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /(node_modules|bower_components)/,
      use: {
        loader: 'babel-loader',
        options: {
          presets: ['@babel/preset-env']
        }
      }
    }
  ]
}
```

上面的属性表示babel无需对 node_modules 文件夹或者 bower_components 文件夹做任何处理。

### 开启 loader 的cache 功能

有些 loader支持缓存功能，比如说 babel-loader 可以配置`cacheDirectory`属性,这个功能开启后能够用指定目录来缓存 loader 的执行结果。这样当 webpack 再次构建时，能够读取缓存来避免每次执行时，可能产生的高消耗的编译过程。

### DLLPlugin ❌

 DLLPlugin 在 webpack5 中已经不用了，害我配了半天。



### happypack ❌

这个功能跟 thread-loader 差不多，都是开启多进程，webpack5 已经不需要了。



## 2.2 如何更小——缩小打包体积

缩小打包体积的思路有利用一些plugin来缩小代码量，或者利用webpack的Tree-shaking功能来删除没用过的代码。

### mode 属性

使用 `mode` 为 `"production"` 的配置项以启用[更多优化项](https://webpack.docschina.org/concepts/mode/#usage)，包括压缩代码与 tree shaking。

### 开启压缩

通过[optimization](https://webpack.docschina.org/configuration/optimization/#optimizationminimizer)属性开启压缩功能。告知 webpack 使用 [TerserPlugin](https://webpack.docschina.org/plugins/terser-webpack-plugin/) 或其它在 [`optimization.minimizer`](https://webpack.docschina.org/configuration/optimization/#optimizationminimizer)定义的插件压缩 bundle。

```javascript
module.exports = {
  //...
  optimization: {
    minimize: true,
  },
};
```

### 压缩JS

使用webpack5 开箱即用的插件[TerserWebpackPlugin](https://webpack.docschina.org/plugins/terser-webpack-plugin/)来压缩 JavaScript，只需要将插件添加到 `webpack`配置文件中即可。

```javascript
const TerserPlugin = require("terser-webpack-plugin");

module.exports = {
  optimization: {
    minimize: true,//记得开启压缩功能
    minimizer: [new TerserPlugin()],
  },
};
```



### 压缩css

> [Optimize CSS Assets Webpack Plugin](https://www.npmjs.com/package/optimize-css-assets-webpack-plugin)
>
> 使用方式参照官方文档
>
> ```javascript
> var OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
> module.exports = {
>   module: {
>   ...
>   },
>   plugins: [
>     new OptimizeCssAssetsPlugin({
>       assetNameRegExp: /\.optimize\.css$/g,
>       cssProcessor: require('cssnano'),
>       cssProcessorPluginOptions: {
>         preset: ['default', { discardComments: { removeAll: true } }],
>       },
>       canPrint: true
>     })
>   ]
> };
> ```
>
> ❌ 这个插件已经过时了

webpack5 推荐使用 [CssMinimizerWebpackPlugin](https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/) 插件，它在 source maps 和 assets 中使用查询字符串会更加准确，支持缓存和并发模式下运行。

安装

```javascript
$ npm install css-minimizer-webpack-plugin --save-dev
```

**webpack.config.js**

```javascript
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");

module.exports = {
  module: {
    rules: [
      {
        test: /.s?css$/,
        use: [MiniCssExtractPlugin.loader, "css-loader", "sass-loader"],
      },
    ],
  },
  optimization: {
    minimizer: [
      // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释
      // `...`,
      new CssMinimizerPlugin(),
    ],
  },
  plugins: [new MiniCssExtractPlugin()],
};
```

### Tree Shaking

*tree shaking* 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。

`webpack`内置这个功能，只需要通过`mode:"production"`来开启就行。



# 三、优化图片体积

优化图片的体积对于网页的效果是显著的，前端开发者需要根据实际情况对不同的图片合理取舍。

以下是不同图片格式的特点：

* **JPG/JPEG**

  特点是有损压缩，体积小，加载快。适合用于大图，比如 Banner 图、背景图等。

* **PNG-8 与 PNG-24**

  PNG 格式是无损压缩的高保真图片格式，比 JPG 有更多的色彩表现力，缺点是体积太大。适合LOGO 图、一些小图。

* **SVG**

  SVG 是一种矢量图，是基于 XML 语法的图像格式，优点是图片可无限放大不失真，即使放到视网膜屏幕上也能够保持较高的品质，而且 SVG 可被编程，灵活性高。缺点是浏览器渲染成本高。适合用于做图标。

* **Base64**

  Base64 是文本文件，把图片解码成 Base64 字符串直接写入 img 标签中，是可以被浏览器解析成图片的，这样做的好处是不需要再去发送 HTTP 请求即可显示图片，节省了传统的浏览器单独向服务器请求图片资源的HTTP开销。但是过大的图片转成Base64 会给浏览器的解析带来困扰，所以推荐用来放20kb 以内，体积小，更新频率低的图片。

## 3.1 通过 webpack 自动将图片转成 Base64

webpack 有个 asset 模块，支持将图片在打包时直接打包成 Base64 格式，我们需要这样配置：

**webpack.config.js**

```javascript
  module: {
    rules: [
    ...
      {
        test: /\.(png|jpe?g|gif|svg)$/i,
        type: 'asset',
        generator: {
          filename: 'assets/[name].[hash:6][ext]', //输出规则
        },
        parser: {
          dataUrlCondition: {
            maxSize: 20 * 1024, // 小于20kb则解析成dataUrl
          },
        },
      },
    ],
  }
```

上面的配置意思是将 20kb 以内的 png/jpg/jpeg/svg 等打包成Base64，其他的情况依然打包成原来的格式。



## 3.2 WebP图片格式

webP 是 google 提出来专门为 Web 开发的**旨在加快图片加载速度**的图片格式，它支持有损压缩和无损压缩。

它集多种图片文件格式的优点于一身，官方介绍是这样的：

> 与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。

这种图片格式太新，对用户的浏览器来说太新颖的东西兼容性就差。

但目前淘宝依然有很多这种格式图片的应用，以下是淘宝中的某一个图片的链接：

```html
<img src="//img.alicdn.com/bao/uploaded/O1CN01vHdubg1iPXPBfaGpT_!!6000000004405-0-yinhe.jpg_80x80q90.jpg_.webp" alt="冻龄美妆">
```

它在.webp 前面，额外跟了一个.jpg 后缀。

然后用 js判断浏览器能不能支持 webP ，如果不能就使用 JavaScript切割字符串，将 webP 转化为 jpg 格式。



### 转换为 webP 图片

可以手动，也可以加入构建自动化生成。

- 手动，可以使用**webP-converter**、智图等工具，但建议使用官方webP-converter，除了便捷性，同质量下体积各方面均优于智图。

```
./cwebp -q 75 login_plane_2.png -o login_plane_2.webp
复制代码
```

- 自动化生成，可以使用image-min-webp或其他webpack插件



### 建议兼容方案 

比起淘宝的方案，这里有种更简单的方法

* HTML中使用，`<picture>`标签兼容

  ```html
  <picture>
      <source srcset="hehe.webp" type="image/webp">
      <img src="hehe.png" alt="hehe>
  </picture>
  ```

  如果浏览器支持 `image/webp` 类型的图片，则加载 `<source>` 元素中 `srcset` 属性指向的资源，如果不支持则跳过 `<source>` 元素，加载 `<img>` 元素

  

* CSS中使用，需要配合JS做判断

  ```javascript
  // main.js
  window.addEventListener('DOMContentLoaded', () => {
      const isSupportWebP = document.createElement('canvas')
      .toDataURL('image/webp')
      .indexOf('data:image/webp') === 0
      document.documentElement.classList.add(isSupportWebP ? '' : '.no-support-webp');
  })
  // css
  .support-webp .bg{
      background-image: url("hehe.webp");
  }
  
  .no-support-webp .bg {
      background-image: url("hehe.png");
  }
  ```

  就是多写一套 css，然后通过判断是否支持 webP 来给 HTML 标签加类名以触发不同的图片格式。