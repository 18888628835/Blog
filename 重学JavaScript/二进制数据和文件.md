# 一、ArrayBuffer和二进制数组

当我们处理文件时（创建、上传、下载），经常会遇到二进制数据。

在JavaScript中有很多二进制数据的格式，比如

* ArrayBuffer、Unit8Array、DataView、Blob、File等

最基本的二进制对象是ArrayBuffer——对固定长度的连续内存空间的引用。

我们这样来创建它

```javascript
let buffer=new ArrayBuffer(16) //创建一个长度为16的数组缓冲区
buffer.byteLength // 16 访问buffer的字节长度
```

上面的代码会分配一个16字节的连续内存空间，并用0进行预填充。

> 需要注意的是，ArrayBuffer并不是某种东西的数组，它与Array没有任何共同之处：
>
> * 它的长度是固定的，不能像数组一样增加或者减少。
> * 它正好占用那么多内存空间
> * 要访问单个字节，需要用“视图对象”来实现，而不能像数组一样用buffer[index]来访问某个字节

ArrayBuffer是一个内存区域，它里面存储着原始的字节序列。

想要操作ArrayBuffer，我们需要用到“视图对象”

视图对象本身不存储任何东西，它就像一幅眼镜，通过它来解释ArrayBuffer中的字节。

比如以下视图对象：

* Uint8Array —— 将ArrayBuffer中的每个字节都视为0-255之间的单个数字（每个字节是8位）。这称为“8位无符号整数”。
* Uint16Array —— 将每2个字节视为一个0-65535之间的整数。这称为“16位无符号整数”
* Uint32Array —— 将每4个字节视为一个0-4294967295之间的整数。这称为“32位无符号整数”
* Float64Array —— 将每8个字节视为一个`5.0x10-324` 到 `1.8x10308` 之间的浮点数。

比如说，0的二进制是0，1的二进制是01，2的二进制是10，3的二进制是11...255的二进制是1111 1111。

所以Unit8Array的二进制最高为一个字节8位数长度（byteLength），故而最大的整数就是255。以此类推，Unit16Array就占用2个字节，最长为16位。

如果用格子表示字节，那么8位字节下0-255只能占用一个格子，而16位字节下0-255可以占用两个格子。

<img src="assets/image-20211226150300619.png" alt="image-20211226150300619" style="zoom:50%;" />

ArrayBuffer是核心对象，是原始的二进制数据，是所有的基础。

如果我们要对他进行操作（遍历、写入）等，基本上所有的操作，我们都必须使用视图（View）。

```javascript
let buffer = new ArrayBuffer(16);// 创建16位字节长度的buffer
let view = new Uint32Array(buffer);// 用32位的视图对象去读它,将 buffer 视为一个 32 位整数的序列
console.log(Uint32Array.BYTES_PER_ELEMENT); //32位视图对象视角下 每个整数占4字节
console.log("view", view); // {0:0,1:0,2:0,3:0}
console.log(view.length); //4 里面存储4个整数 预设都为0
console.log(view.byteLength); //字节中长度 16

view[0] = 123;
view[1] = 456;
view[2] = 789;

for (let i of view) {
  console.log(i); // 123 456 789 0  一共4个值
}
```

## 1.1、TypedArray

所有的视图有一个通用术语—— TypedArray（类型化数组） 。

它是视图对象的统称术语。并不存在TypedArray的构造函数，它可以用来表示Uint8Array，也可以用来表示Uint64Array等视图。

之所以用这个统称是因为所有视图对象都有同一组方法和属性，用统称的形式更容易表达。

类型化数组的行为类似于常规数组：具有索引，也可以被迭代。

一个类型化数组的构造器（不管是Int8Array还是Float64Array都无关紧要），它们的行为取决于参数类型。

参数有5种变体：

```javascript
new TypedArray(buffer, [byteOffset], [length]);
new TypedArray(object);
new TypedArray(typedArray);
new TypedArray(length);
new TypedArray();
```

1. 如果参数是一个buffer对象，则会创建一个视图。后面的参数则是可选的。

   byteOffset是起始位置（默认为0）以及length（默认是buffer的末尾），我们可以指定buffer的某些部分。

2. 如果给定的是Array，或者是其他类数组对象，则会创建一个相同长度的类型化数组，并复制其内容。

   ```javascript
   let arr = new Uint16Array([1, 2, 3, 4, 5]);
   console.log(arr.length); // 5
   console.log(arr[1]); // 2
   console.log(Array.isArray(arr)); // false 说明返回的是类型化数组
   ```

3. 如果给定的是另一个类型化数组(TypedArray),会创建一个相同长度的类型化数组，并复制其内容。

   ```javascript
   let arr16 = new Uint16Array([1, 1000]);
   let arr8 = new Uint8Array(arr16);
   console.log(arr8[0]); // 1
   console.log(arr8[1]); // 232 试图复制 1000，但无法将 1000 放进 8 位字节中
   ```

4. 对于数字参数length —— 创建类型化数组可以包含那么多元素，它的字节长度是length乘以单个TypedArray.BYTES_PER_ELEMENT的字节数。

   ```javascript
   let arr = new Uint16Array(4); // 为 4 个整数创建类型化数组
   alert(Uint16Array.BYTES_PER_ELEMENT); // 每个整数 2 个字节
   alert(arr.byteLength); // 8（字节中的大小）
   ```

5. 不带参数的情况下，创建长度为0的类型化数组。

我们可以直接创建一个TypedArray，而无需传入ArrayBuffer。但是视图离不开底层的ArrayBuffer，因此，除第一种情况（提供buffer）外，其他所有情况都会自动创建ArrayBuffer。

想要访问自动创建的ArrayBuffer,可以用以下属性：

* arr.buffer —— 引用ArratBuffer
* arr.byteLength —— ArrayBuffer的字节长度

因此，我们总是可以从一个视图转换到另一个视图

```javascript
let arr8 = new Uint8Array([0, 1, 2, 3]);

// 同一数据的另一个视图
let arr16 = new Uint16Array(arr8.buffer);
```

## 1.2、越界行为

当我们将越界值写入类型化数组时，多余的位会被切除。

比如，Uint8Array的最大字节长度为8，当我们放入256时，256的二进制值为100000000（9位数），但是Unit8Array最大字节数只能放8位，于是仅保存最右边的8位，其余部分会被切除。

<img src="assets/image-20211226162552905.png" alt="image-20211226162552905" style="zoom:50%;" />

所以结果会是0。

257的二进制格式位100000001，最右边的8位会被储存，因此数组中会有1

<img src="assets/image-20211226162641911.png" alt="image-20211226162641911" style="zoom:50%;" />

## 1.3、TypedArray方法

TypedArray方法具有常规的Array方法，但是有个明显的例外

我们可以遍历（部署了iterate接口），map、slice、find和reduce等。

但是我们没办法做：

* 没有splice —— 因为我们没办法删除一个值，因为类型化数组时缓冲区（buffer）的视图，并且缓冲区（buffer）是固定的、连续的内存区域。我们所能做的就是分配一个零值。
* 没有concat方法

但拥有两种其他方法：

* `arr.set(fromArr,[offset])`从offset开始。将`fromArr`中的所有元素复制到arr
* `arr.subarray([begin,end])`创建一个从`begin`到`end`（不包括）相同类型的新视图。这有点类似于slice方法，但不复制任何内容 —— 只是创建一个新视图，以对给定片段地数据进行操作。

## 1.4、DataView

`DataView`是在`ArrayBuffer`上的一种特殊的超灵活`未类型化`的视图，它允许以任何格式访问任何偏移量（offset）的数据。

* 对于类型化的数组，构造器决定了其格式。整个数组应该是统一的，第i个数字是`arr[i]`。
* 通过DataView。我们可以使用`.getUint8(i)`或者`.getUint16(i)`之类的方法访问数据。我们在调用方法时选择格式，而不是在构造的时候。

语法：

```javascript
new DataView(buffer,[byteOffset],[byteLength])
```

* Buffer ——底层的ArrayBuffer。与类型化数组不同的是，DataView不会自己创建缓冲区（buffer）。我们需要实现准备好。
* byteOffset —— 视图的起始字节位置（默认为0）
* byteLength —— 视图的字节长度（默认到buffer的末尾）

例如，这里我们从同一个buffer中提取不同格式的数字：

```javascript
// 4 个字节的二进制数组，每个都是最大值 255
let buffer = new Uint8Array([255, 255, 255, 255]).buffer;

let dataView = new DataView(buffer);

// 在偏移量为 0 处获取 8 位数字
alert( dataView.getUint8(0) ); // 255

// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535
alert( dataView.getUint16(0) ); // 65535（最大的 16 位无符号整数）

// 在偏移量为 0 处获取 32 位数字
alert( dataView.getUint32(0) ); // 4294967295（最大的 32 位无符号整数）

dataView.setUint32(0, 0); // 将 4 个字节的数字设为 0，即将所有字节都设为 0
```

## 1.5、小结

ArrayBuffer是核心对象，是对固定长度的连续内存区域的引用。

几乎任何对ArrayBuffer的操作，都需要一个视图来完成。

* 视图可以是TypedArray：
  * `Uint8Array`，`Uint16Array`，`Uint32Array` —— 用于 8 位、16 位和 32 位无符号整数。
  * `Uint8ClampedArray` —— 用于 8 位整数，在赋值时便“固定”其值。
  * `Int8Array`，`Int16Array`，`Int32Array` —— 用于有符号整数（可以为负数）。
  * `Float32Array`，`Float64Array` —— 用于 32 位和 64 位的有符号浮点数。
* DataView —— 使用方法来指定格式的视图，例如：getUint8(offset)

在大多数情况下，我们直接对类型化数组进行创建和操作，而将ArrayBuffer作为通用标识符隐藏起来。我们可以通过`.buffer`来访问它，并在需要时创建另一个视图。

另外还有两个术语，用于对二进制数据进行操作的方法的描述：

* ArrayBufferView是所有这些视图的总称
* BufferSource是ArrayBuffer或者ArrayBufferView的总称



# 二、TextDecoder和TextEncoder

## 2.1、TextDecoder

如果二进制数据实际上是一个字符串，我们可以用textDecoder对象在给定缓冲区buffer和编码格式encoding的情况下，将值读取到实际的字符串。可以理解为这是给实际内容字符串的二进制数据解码。

语法是这样的

1. 创建一个解码对象

   ```javascript
   let decoder=new TextDecoder([label],[options])
   ```

   label —— 编码格式，默认为`utf-8`，同时也支持big5、windows-1251等编码格式

   options —— 可选对象：

   * fatal —— 布尔值，如果为`true`则为无效字符（不可解码）字符抛出异常，否则用字符`\uFFFD`替换无效字符。
   * ignoreBOM —— 布尔值，如果为`true`则BOM（可选的字节顺序unicode标记）

2. 解码

   ```javascript
   let str = decoder.decode([input],[options])
   ```

   * Input —— 要被解码的`BufferSource`
   * options —— 可选对象：
     * stream —— 对于解码流，为true，则将传入的数据块（chunk）作为参数重复调用decoder。在这种情况下，多字节的字符可能偶尔会在块与块之间分割。这个选项告诉TextDecoder记住未完成的字符，并在下一个数据块来的时候进行解码

以下为例子

```javascript
let uint8Array = new Uint8Array([72, 101, 108, 108, 111]);

alert( new TextDecoder().decode(uint8Array) ); // Hello
```

我们可以通过为其创建子数组视图来解码部分缓冲区：

```javascript
let uint8Array = new Uint8Array([0, 72, 101, 108, 108, 111, 0]);

// 该字符串位于中间
// 在不复制任何内容的前提下，创建一个新的视图
let binaryString = uint8Array.subarray(1, -1);

alert( new TextDecoder().decode(binaryString) ); // Hello
```

## 2.2、TextEncoder

[TextEncoder](https://encoding.spec.whatwg.org/#interface-textencoder) 做相反的事情 —— 将字符串转换为字节。

语法：

```javascript
let encoder = new TextEncoder();
```

只支持utf-8编码。

它有两种方法：

- **`encode(str)`** —— 从字符串返回 `Uint8Array`。
- **`encodeInto(str, destination)`** —— 将 `str` 编码到 `destination` 中，该目标必须为 `Uint8Array`。

```javascript
let encoder = new TextEncoder();

let uint8Array = encoder.encode("Hello");
alert(uint8Array); // 72,101,108,108,111
```

